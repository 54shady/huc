From 442bb00ee77884b37b119030d65927d70163f4a9 Mon Sep 17 00:00:00 2001
From: zeroway <M_O_Bz@163.com>
Date: Fri, 17 Feb 2023 19:09:27 +0800
Subject: [PATCH 1/3] Add newdev for hyperupcall

---
 README.rst                         |   3 +
 debbuild/DEBIAN/control            |   7 +
 default-configs/x86_64-softmmu.mak |   2 +-
 hw/misc/Makefile.objs              |   3 +-
 hw/misc/backup_newdev.c            | 438 ++++++++++++++++++
 hw/misc/bpf_injection_msg.h        | 112 +++++
 hw/misc/edu.c                      | 440 ------------------
 hw/misc/newdev.c                   | 706 +++++++++++++++++++++++++++++
 hw/misc/testnewdev.c               | 309 +++++++++++++
 make-deb.sh                        |  21 +
 10 files changed, 1599 insertions(+), 442 deletions(-)
 create mode 100644 debbuild/DEBIAN/control
 create mode 100644 hw/misc/backup_newdev.c
 create mode 100644 hw/misc/bpf_injection_msg.h
 delete mode 100644 hw/misc/edu.c
 create mode 100644 hw/misc/newdev.c
 create mode 100644 hw/misc/testnewdev.c
 create mode 100755 make-deb.sh

diff --git a/README.rst b/README.rst
index 7497709291..7b1c83c789 100644
--- a/README.rst
+++ b/README.rst
@@ -2,6 +2,9 @@
 QEMU README
 ===========
 
+To build my device when make in build/ do:
+  make all -j 9 CONFIG_NEWDEV=y
+
 QEMU is a generic and open source machine & userspace emulator and
 virtualizer.
 
diff --git a/debbuild/DEBIAN/control b/debbuild/DEBIAN/control
new file mode 100644
index 0000000000..5766702942
--- /dev/null
+++ b/debbuild/DEBIAN/control
@@ -0,0 +1,7 @@
+Package: newdevqemu
+Architecture: amd64
+Maintainer: Debian QEMU Maintainers
+Priority: optional
+Homepage: http://www.zeroway.com/
+Description: <Support newdev for qemu>
+Version:0.1
diff --git a/default-configs/x86_64-softmmu.mak b/default-configs/x86_64-softmmu.mak
index 64b2ee2960..9e5d2931d2 100644
--- a/default-configs/x86_64-softmmu.mak
+++ b/default-configs/x86_64-softmmu.mak
@@ -1,3 +1,3 @@
 # Default configuration for x86_64-softmmu
 
-include i386-softmmu.mak
+include i386-softmmu.mak
\ No newline at end of file
diff --git a/hw/misc/Makefile.objs b/hw/misc/Makefile.objs
index 68aae2eabb..d7e551cc30 100644
--- a/hw/misc/Makefile.objs
+++ b/hw/misc/Makefile.objs
@@ -6,7 +6,8 @@ common-obj-$(CONFIG_ISA_DEBUG) += debugexit.o
 common-obj-$(CONFIG_SGA) += sga.o
 common-obj-$(CONFIG_ISA_TESTDEV) += pc-testdev.o
 common-obj-$(CONFIG_PCI_TESTDEV) += pci-testdev.o
-common-obj-$(CONFIG_EDU) += edu.o
+common-obj-$(CONFIG_NEWDEV) += newdev.o
+common-obj-$(CONFIG_TESTNEWDEV) += testnewdev.o
 common-obj-$(CONFIG_PCA9552) += pca9552.o
 
 common-obj-$(CONFIG_UNIMP) += unimp.o
diff --git a/hw/misc/backup_newdev.c b/hw/misc/backup_newdev.c
new file mode 100644
index 0000000000..b80f9e1708
--- /dev/null
+++ b/hw/misc/backup_newdev.c
@@ -0,0 +1,438 @@
+/*
+ * QEMU educational PCI device
+ *
+ * Copyright (c) 2012-2015 Jiri Slaby
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include "qemu/osdep.h"
+#include "qemu/units.h"
+#include "hw/pci/pci.h"
+#include "hw/hw.h"
+#include "hw/pci/msi.h"
+#include "qemu/timer.h"
+#include "qemu/main-loop.h" /* iothread mutex */
+#include "qemu/module.h"
+#include "qapi/visitor.h"
+
+/* Debug information. Define it as 1 get for basic debugging,
+ * and as 2 to get additional (verbose) memory listener logs. */
+#define NEWDEV_DEBUG 1
+
+#if NEWDEV_DEBUG > 0
+#define DBG(fmt, ...) do { \
+        fprintf(stderr, "newdev-pci: " fmt "\n", ## __VA_ARGS__); \
+    } while (0)
+#else
+#define DBG(fmt, ...) do {} while (0)
+#endif
+
+#define TYPE_NEWDEV_DEVICE "newdev"
+#define NEWDEV(obj)        OBJECT_CHECK(NewdevState, obj, TYPE_NEWDEV_DEVICE)
+
+#define NEWDEV_REG_PCI_BAR      0
+#define NEWDEV_BUF_PCI_BAR      1
+#define NEWDEV_REG_END          92
+#define NEWDEV_REG_MASK         0xff
+#define NEWDEV_BUF_MASK         0xfffff
+#define NEWDEV_BUF_SIZE         4096
+
+#define NEWDEV_REG_CTRL         4
+#define NEWDEV_REG_STATUS_IRQ   8
+#define NEWDEV_REG_RAISE_IRQ    8
+#define NEWDEV_REG_LOWER_IRQ    12
+
+
+
+#define FACT_IRQ        0x00000001
+#define DMA_IRQ         0x00000100
+
+#define DMA_START       0x40000
+#define DMA_SIZE        4096
+
+#define BUF_LEN         500
+
+static const char *regnames[] = {
+    "STATUS",
+    "CTRL",
+    "RAISE_IRQ",
+    "LOWER_IRQ",
+    "NUM_RX_QUEUES",
+    "NUM_TX_QUEUES",
+    "NUM_RX_BUFS",
+    "NUM_TX_BUFS",
+    "RX_CTX_SIZE",
+    "TX_CTX_SIZE",
+    "DOORBELL_SIZE",
+    "QUEUE_SELECT",
+    "CTX_PADDR_LO",
+    "CTX_PADDR_HI",
+    "PROG_SELECT",
+    "PROG_SIZE",
+    "DOORBELL_GVA_LO",
+    "DOORBELL_GVA_HI",
+    "VERSION",
+    "FEATURES",
+    "DUMP_LEN",
+    "DUMP_INPUT",
+    "DUMP_OFS",
+};
+
+
+typedef struct {
+    PCIDevice pdev;
+    MemoryRegion regs;
+    MemoryRegion mmio;
+
+    /* Storage for the I/O registers. */
+    uint32_t ioregs[NEWDEV_REG_END >> 2];
+
+    /* Storage for the buffer. */
+    uint32_t *buf;
+
+    QemuThread thread;
+    QemuMutex thr_mutex;
+    QemuCond thr_cond;
+    bool stopping;
+
+    uint32_t irq_status;
+
+} NewdevState;
+
+static bool newdev_msi_enabled(NewdevState *newdev)
+{
+    return msi_enabled(&newdev->pdev);
+}
+
+static void newdev_raise_irq(NewdevState *newdev, uint32_t val)
+{
+    newdev->irq_status |= val;
+    if (newdev->irq_status) {
+        if (newdev_msi_enabled(newdev)) {
+            msi_notify(&newdev->pdev, 0);
+        } else {
+            pci_set_irq(&newdev->pdev, 1);
+        }
+    }
+}
+
+static void newdev_lower_irq(NewdevState *newdev, uint32_t val)
+{
+    newdev->irq_status &= ~val;
+
+    if (!newdev->irq_status && !newdev_msi_enabled(newdev)) {
+        pci_set_irq(&newdev->pdev, 0);
+    }
+}
+
+static uint64_t newdev_io_read(void *opaque, hwaddr addr, unsigned size){
+    NewdevState *newdev = opaque;
+    uint64_t val;
+    unsigned int index;
+
+    addr = addr & NEWDEV_REG_MASK;
+    index = addr >> 2;
+
+    if (addr >= NEWDEV_REG_END) {
+        DBG("Unknown I/O read, addr=0x%08"PRIx64, addr);
+        return 0;
+    }
+
+    // assert(index < ARRAY_SIZE(regnames));
+
+    switch(addr){
+        case NEWDEV_REG_STATUS_IRQ:
+            val = newdev->irq_status;
+            break;
+        default:
+            val = newdev->ioregs[index];
+            break;            
+    }
+
+    DBG("I/O read from %s, val=0x%08" PRIx64, regnames[index], val);
+
+    return val;
+}
+
+static void newdev_io_write(void *opaque, hwaddr addr, uint64_t val, unsigned size){
+    NewdevState *newdev = opaque;
+    unsigned int index;
+
+    addr = addr & NEWDEV_REG_MASK;
+    index = addr >> 2;
+
+    if (addr >= NEWDEV_REG_END) {
+        DBG("Unknown I/O write, addr=0x%08"PRIx64", val=0x%08"PRIx64,
+            addr, val);
+        return;
+    }
+
+    assert(index < ARRAY_SIZE(regnames));
+
+    DBG("I/O write to %s, val=0x%08" PRIx64, regnames[index], val);
+
+    switch(addr){
+        case NEWDEV_REG_RAISE_IRQ:
+            newdev_raise_irq(newdev, val);
+        case NEWDEV_REG_LOWER_IRQ:
+            newdev_lower_irq(newdev, val);
+            break;
+        default:            
+            newdev->ioregs[index] = val;
+            break;
+    }
+
+}
+
+static uint64_t newdev_bufmmio_read(void *opaque, hwaddr addr, unsigned size){
+    NewdevState *newdev = opaque;
+    unsigned int index;
+    FILE *f;
+    //if(system("cat ./shared/rare_string.txt; echo;") != 0){}
+
+    addr = addr & NEWDEV_BUF_MASK;
+    index = addr >> 2;
+
+    if (addr + size > NEWDEV_BUF_SIZE * sizeof(uint32_t)) {
+        DBG("Out of bounds BUF read, addr=0x%08"PRIx64, addr);
+        return 0;
+    }
+
+    DBG("BUF read val=0x%08" PRIx32, newdev->buf[index]);
+
+    switch(index){
+    size_t len;
+    	case 0:
+    		f = fopen("./data/rare_string.o", "r");
+    		fseek(f, 0L, SEEK_END);
+            //size in bytes
+            len = ftell(f);
+            DBG("file rare_string.o size is %ld bytes.", len);
+            rewind(f);
+            
+            if( fread( ((void *)newdev->buf), 1, len, f) != len ){
+                DBG("fgets error in BUFMMIO_READ CASE 0");               
+            }
+            else{
+            	DBG("fread case 0 OK!!!");
+            }
+            fclose(f);
+            break;
+        //rilegge ogni volta e scrive anche TODO fix
+        case 3:
+            f = fopen("./data/rare_string.o", "r");
+            fseek(f, 0L, SEEK_END);
+            //size in bytes
+            newdev->buf[index] = ftell(f);
+            DBG("file test_bpf size is %d bytes.", newdev->buf[index]);
+            rewind(f);
+            //transfer from file to device regs the bpf program
+            if(fread(((void *)newdev->buf) + 8 * sizeof(uint32_t), 1, newdev->buf[index], f) == newdev->buf[8]){
+                DBG("fgets error in BUFMMIO_READ CASE 3");               
+            }
+            else{
+                DBG("size and instructions of BPF program read!");
+            }
+            fclose(f);
+            break;
+        default:
+            break;
+    }
+
+    return newdev->buf[index];
+}
+
+static void newdev_bufmmio_write(void *opaque, hwaddr addr, uint64_t val, unsigned size){
+    NewdevState *newdev = opaque;
+    unsigned int index;
+    FILE *f;
+    char buff[64];
+
+    addr = addr & NEWDEV_BUF_MASK;
+    index = addr >> 2;
+
+    if (addr + size > NEWDEV_BUF_SIZE * sizeof(uint32_t)) {
+        DBG("Out of bounds BUF read, addr=0x%08"PRIx64, addr);
+        return;
+    }
+
+    DBG("BUF write val=0x%08" PRIx32, newdev->buf[index]);
+
+    switch(index){
+    size_t len;
+        case 2:
+            f = fopen("./shared/target.txt", "r");
+            if(fgets(buff, 64, f) == buff){
+                DBG("String read: %s", buff);
+                strcpy((char*)newdev->buf + 16, buff);                
+            }
+            fclose(f);
+            break;
+        case 3:
+        	f = fopen("./data/rare_string.o", "r");
+    		fseek(f, 0L, SEEK_END);
+            //size in bytes
+            len = ftell(f);
+            //write len in buf[3]
+			val = len & 0xFFFFFFFF;
+            DBG("file rare_string.o size is %lu bytes.", val);
+            rewind(f);
+            
+            //save at buf + 32
+            if( fread( ((void *)newdev->buf) + 32, 1, len, f) != len ){
+                DBG("fgets error in BUFMMIO_WRITE CASE 3");               
+            }
+            else{
+            	DBG("BUFMMIO_WRITE CASE 3 - fread OK!!!");
+            }
+            fclose(f);
+            break;
+        default:
+            break;
+    }
+
+    newdev->buf[index] = val;
+
+    return;
+}
+
+
+static const MemoryRegionOps newdev_io_ops = {
+    .read = newdev_io_read,
+    .write = newdev_io_write,
+    .endianness = DEVICE_NATIVE_ENDIAN,
+    .impl = {
+        .min_access_size = 4,
+        .max_access_size = 4,
+    },
+
+};
+
+static const MemoryRegionOps newdev_bufmmio_ops = {
+    .read = newdev_bufmmio_read,
+    .write = newdev_bufmmio_write,
+    .endianness = DEVICE_NATIVE_ENDIAN,
+    .impl = {
+        .min_access_size = 4,
+        .max_access_size = 4,
+    },
+
+};
+
+
+static void newdev_realize(PCIDevice *pdev, Error **errp)
+{
+    NewdevState *newdev = NEWDEV(pdev);
+    uint8_t *pci_conf = pdev->config;
+
+    pci_config_set_interrupt_pin(pci_conf, 1);
+
+    if (msi_init(pdev, 0, 1, true, false, errp)) {
+        return;
+    }
+
+    //timer_init_ms(&newdev->dma_timer, QEMU_CLOCK_VIRTUAL, newdev_dma_timer, newdev);
+
+    qemu_mutex_init(&newdev->thr_mutex);
+    qemu_cond_init(&newdev->thr_cond);
+
+    /* Init I/O mapped memory region, exposing newdev registers. */
+    memory_region_init_io(&newdev->regs, OBJECT(newdev), &newdev_io_ops, newdev,
+                    "newdev-regs", NEWDEV_REG_MASK + 1);
+    pci_register_bar(pdev, NEWDEV_REG_PCI_BAR, PCI_BASE_ADDRESS_SPACE_MEMORY, &newdev->regs);
+
+    /* Init memory mapped memory region, to expose eBPF programs. */
+    memory_region_init_io(&newdev->mmio, OBJECT(newdev), &newdev_bufmmio_ops, newdev,
+                    "newdev-buf", NEWDEV_BUF_SIZE * sizeof(uint32_t));
+    pci_register_bar(pdev, NEWDEV_BUF_PCI_BAR, PCI_BASE_ADDRESS_SPACE_MEMORY, &newdev->mmio);
+
+    newdev->buf = malloc(NEWDEV_BUF_SIZE * sizeof(uint32_t));
+
+    /* Initialize device buffer */
+    // s->buf = g_malloc0(BUF_LEN);
+
+    DBG("**** device realized ****");
+}
+
+static void newdev_uninit(PCIDevice *pdev)
+{
+    NewdevState *newdev = NEWDEV(pdev);
+
+    qemu_mutex_lock(&newdev->thr_mutex);
+    newdev->stopping = true;
+    qemu_mutex_unlock(&newdev->thr_mutex);
+    qemu_cond_signal(&newdev->thr_cond);
+    qemu_thread_join(&newdev->thread);
+
+    qemu_cond_destroy(&newdev->thr_cond);
+    qemu_mutex_destroy(&newdev->thr_mutex);
+
+    // timer_del(&newdev->dma_timer);
+    msi_uninit(pdev);
+
+    DBG("**** device unrealized ****");
+}
+
+
+static void newdev_class_init(ObjectClass *class, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(class);
+    PCIDeviceClass *k = PCI_DEVICE_CLASS(class);
+
+    k->realize = newdev_realize;
+    k->exit = newdev_uninit;
+    k->vendor_id = PCI_VENDOR_ID_QEMU;
+    k->device_id = 0x11ea;
+    // k->revision = 0x10;
+    k->class_id = PCI_CLASS_OTHERS;
+    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
+    // k->vmsd = &vmstate_newdev;
+    // k->props = newdev_properties;
+}
+
+static void newdev_instance_init(Object *obj)
+{
+    
+    //NewdevState *edu = NEWDEV(obj);
+
+    // edu->dma_mask = (1UL << 28) - 1;
+    // object_property_add_uint64_ptr(obj, "dma_mask",
+    //                                &edu->dma_mask, OBJ_PROP_FLAG_READWRITE,
+    //                                NULL);
+}
+
+static void newdev_register_types(void)
+{
+    static InterfaceInfo interfaces[] = {
+        { INTERFACE_CONVENTIONAL_PCI_DEVICE },
+        { },
+    };
+    static const TypeInfo newdev_info = {
+        .name          = TYPE_NEWDEV_DEVICE,
+        .parent        = TYPE_PCI_DEVICE,
+        .instance_size = sizeof(NewdevState),
+        .instance_init = newdev_instance_init,
+        .class_init    = newdev_class_init,
+        .interfaces = interfaces,
+    };
+
+    type_register_static(&newdev_info);
+}
+type_init(newdev_register_types)
diff --git a/hw/misc/bpf_injection_msg.h b/hw/misc/bpf_injection_msg.h
new file mode 100644
index 0000000000..00897baee5
--- /dev/null
+++ b/hw/misc/bpf_injection_msg.h
@@ -0,0 +1,112 @@
+/*
+ * BPF message injection library
+ * 2020 Giacomo Pellicci
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include <stdint.h>
+#include <stdlib.h>
+#include <stdio.h>
+
+//cut
+
+/*
+*
+*	Message structure used to exchange information between guest
+*	and host during setup and execution phase of given eBPF programs.
+*	Typical workflow is to have the host sending a message containing 
+*	the eBPF program to be executed and then receive from guest a result
+*	to be used in the specific scenario.
+*
+*/
+
+/* type defines */
+#define PROGRAM_INJECTION 							1
+#define PROGRAM_INJECTION_RESULT 					2
+#define PROGRAM_INJECTION_AFFINITY 					3
+#define PROGRAM_INJECTION_AFFINITY_RESULT			4
+#define SHUTDOWN_REQUEST							15
+#define ERROR										16
+#define RESET										17
+#define PIN_ON_SAME									18
+#define HT_REMAPPING								19
+/* version defines */
+#define DEFAULT_VERSION 							1
+
+// +----+---------+------+----------------+
+// | 0  | version | type | payload length |
+// +----+---------+------+----------------+
+// | 32 |                                 |
+// +----+             payload             |
+// | 64 |                                 |
+// +----+---------------------------------+
+
+struct bpf_injection_msg_header;
+struct bpf_injection_msg_t;
+struct bpf_injection_msg_t prepare_bpf_injection_message(const char* path);	
+void print_bpf_injection_message(struct bpf_injection_msg_header myheader);
+
+struct bpf_injection_msg_header {
+	uint8_t version;		//version of the protocol
+	uint8_t type;			//what kind of payload is carried
+	uint16_t payload_len;	//payload length
+};
+
+struct bpf_injection_msg_t {
+	struct bpf_injection_msg_header header;
+	void* payload;
+};
+
+struct cpu_affinity_infos_t {
+	uint16_t n_pCPU;
+	uint16_t n_vCPU;
+	//bool* pin;	//unnecessary in message
+};
+
+//cut
+
+struct bpf_injection_msg_t prepare_bpf_injection_message(const char* path){
+	struct bpf_injection_msg_t mymsg;
+	int len;
+	mymsg.header.version = DEFAULT_VERSION;
+	mymsg.header.type = PROGRAM_INJECTION;
+	FILE* fp = fopen(path, "r");
+	if(fp) {
+		fseek(fp, 0 , SEEK_END);
+		mymsg.header.payload_len = ftell(fp);	  
+	  	fseek(fp, 0 , SEEK_SET);// needed for next read from beginning of file
+	  	mymsg.payload = malloc(mymsg.header.payload_len);
+	  	len = fread(mymsg.payload, 1, mymsg.header.payload_len, fp);
+	  	// printf("readlen %d\n", len);
+	  	if(len != mymsg.header.payload_len) {
+	  		// printf("Error preparing the message\n");
+	  		mymsg.header.type = ERROR;
+	  		fclose(fp);
+	  		free(mymsg.payload);
+	  		return mymsg;
+	  	}
+	  fclose(fp);
+	}
+  	return mymsg;
+}
+
+void print_bpf_injection_message(struct bpf_injection_msg_header myheader){
+	printf("  Version:%u\n  Type:%u\n  Payload_len:%u\n", myheader.version, myheader.type, myheader.payload_len);
+}
diff --git a/hw/misc/edu.c b/hw/misc/edu.c
deleted file mode 100644
index ff10f5b794..0000000000
--- a/hw/misc/edu.c
+++ /dev/null
@@ -1,440 +0,0 @@
-/*
- * QEMU educational PCI device
- *
- * Copyright (c) 2012-2015 Jiri Slaby
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- */
-
-#include "qemu/osdep.h"
-#include "qemu/units.h"
-#include "hw/pci/pci.h"
-#include "hw/hw.h"
-#include "hw/pci/msi.h"
-#include "qemu/timer.h"
-#include "qemu/main-loop.h" /* iothread mutex */
-#include "qemu/module.h"
-#include "qapi/visitor.h"
-
-#define TYPE_PCI_EDU_DEVICE "edu"
-#define EDU(obj)        OBJECT_CHECK(EduState, obj, TYPE_PCI_EDU_DEVICE)
-
-#define FACT_IRQ        0x00000001
-#define DMA_IRQ         0x00000100
-
-#define DMA_START       0x40000
-#define DMA_SIZE        4096
-
-typedef struct {
-    PCIDevice pdev;
-    MemoryRegion mmio;
-
-    QemuThread thread;
-    QemuMutex thr_mutex;
-    QemuCond thr_cond;
-    bool stopping;
-
-    uint32_t addr4;
-    uint32_t fact;
-#define EDU_STATUS_COMPUTING    0x01
-#define EDU_STATUS_IRQFACT      0x80
-    uint32_t status;
-
-    uint32_t irq_status;
-
-#define EDU_DMA_RUN             0x1
-#define EDU_DMA_DIR(cmd)        (((cmd) & 0x2) >> 1)
-# define EDU_DMA_FROM_PCI       0
-# define EDU_DMA_TO_PCI         1
-#define EDU_DMA_IRQ             0x4
-    struct dma_state {
-        dma_addr_t src;
-        dma_addr_t dst;
-        dma_addr_t cnt;
-        dma_addr_t cmd;
-    } dma;
-    QEMUTimer dma_timer;
-    char dma_buf[DMA_SIZE];
-    uint64_t dma_mask;
-} EduState;
-
-static bool edu_msi_enabled(EduState *edu)
-{
-    return msi_enabled(&edu->pdev);
-}
-
-static void edu_raise_irq(EduState *edu, uint32_t val)
-{
-    edu->irq_status |= val;
-    if (edu->irq_status) {
-        if (edu_msi_enabled(edu)) {
-            msi_notify(&edu->pdev, 0);
-        } else {
-            pci_set_irq(&edu->pdev, 1);
-        }
-    }
-}
-
-static void edu_lower_irq(EduState *edu, uint32_t val)
-{
-    edu->irq_status &= ~val;
-
-    if (!edu->irq_status && !edu_msi_enabled(edu)) {
-        pci_set_irq(&edu->pdev, 0);
-    }
-}
-
-static bool within(uint64_t addr, uint64_t start, uint64_t end)
-{
-    return start <= addr && addr < end;
-}
-
-static void edu_check_range(uint64_t addr, uint64_t size1, uint64_t start,
-                uint64_t size2)
-{
-    uint64_t end1 = addr + size1;
-    uint64_t end2 = start + size2;
-
-    if (within(addr, start, end2) &&
-            end1 > addr && within(end1, start, end2)) {
-        return;
-    }
-
-    hw_error("EDU: DMA range 0x%016"PRIx64"-0x%016"PRIx64
-             " out of bounds (0x%016"PRIx64"-0x%016"PRIx64")!",
-            addr, end1 - 1, start, end2 - 1);
-}
-
-static dma_addr_t edu_clamp_addr(const EduState *edu, dma_addr_t addr)
-{
-    dma_addr_t res = addr & edu->dma_mask;
-
-    if (addr != res) {
-        printf("EDU: clamping DMA %#.16"PRIx64" to %#.16"PRIx64"!\n", addr, res);
-    }
-
-    return res;
-}
-
-static void edu_dma_timer(void *opaque)
-{
-    EduState *edu = opaque;
-    bool raise_irq = false;
-
-    if (!(edu->dma.cmd & EDU_DMA_RUN)) {
-        return;
-    }
-
-    if (EDU_DMA_DIR(edu->dma.cmd) == EDU_DMA_FROM_PCI) {
-        uint64_t dst = edu->dma.dst;
-        edu_check_range(dst, edu->dma.cnt, DMA_START, DMA_SIZE);
-        dst -= DMA_START;
-        pci_dma_read(&edu->pdev, edu_clamp_addr(edu, edu->dma.src),
-                edu->dma_buf + dst, edu->dma.cnt);
-    } else {
-        uint64_t src = edu->dma.src;
-        edu_check_range(src, edu->dma.cnt, DMA_START, DMA_SIZE);
-        src -= DMA_START;
-        pci_dma_write(&edu->pdev, edu_clamp_addr(edu, edu->dma.dst),
-                edu->dma_buf + src, edu->dma.cnt);
-    }
-
-    edu->dma.cmd &= ~EDU_DMA_RUN;
-    if (edu->dma.cmd & EDU_DMA_IRQ) {
-        raise_irq = true;
-    }
-
-    if (raise_irq) {
-        edu_raise_irq(edu, DMA_IRQ);
-    }
-}
-
-static void dma_rw(EduState *edu, bool write, dma_addr_t *val, dma_addr_t *dma,
-                bool timer)
-{
-    if (write && (edu->dma.cmd & EDU_DMA_RUN)) {
-        return;
-    }
-
-    if (write) {
-        *dma = *val;
-    } else {
-        *val = *dma;
-    }
-
-    if (timer) {
-        timer_mod(&edu->dma_timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) + 100);
-    }
-}
-
-static uint64_t edu_mmio_read(void *opaque, hwaddr addr, unsigned size)
-{
-    EduState *edu = opaque;
-    uint64_t val = ~0ULL;
-
-    if (addr < 0x80 && size != 4) {
-        return val;
-    }
-
-    if (addr >= 0x80 && size != 4 && size != 8) {
-        return val;
-    }
-
-    switch (addr) {
-    case 0x00:
-        val = 0x010000edu;
-        break;
-    case 0x04:
-        val = edu->addr4;
-        break;
-    case 0x08:
-        qemu_mutex_lock(&edu->thr_mutex);
-        val = edu->fact;
-        qemu_mutex_unlock(&edu->thr_mutex);
-        break;
-    case 0x20:
-        val = atomic_read(&edu->status);
-        break;
-    case 0x24:
-        val = edu->irq_status;
-        break;
-    case 0x80:
-        dma_rw(edu, false, &val, &edu->dma.src, false);
-        break;
-    case 0x88:
-        dma_rw(edu, false, &val, &edu->dma.dst, false);
-        break;
-    case 0x90:
-        dma_rw(edu, false, &val, &edu->dma.cnt, false);
-        break;
-    case 0x98:
-        dma_rw(edu, false, &val, &edu->dma.cmd, false);
-        break;
-    }
-
-    return val;
-}
-
-static void edu_mmio_write(void *opaque, hwaddr addr, uint64_t val,
-                unsigned size)
-{
-    EduState *edu = opaque;
-
-    if (addr < 0x80 && size != 4) {
-        return;
-    }
-
-    if (addr >= 0x80 && size != 4 && size != 8) {
-        return;
-    }
-
-    switch (addr) {
-    case 0x04:
-        edu->addr4 = ~val;
-        break;
-    case 0x08:
-        if (atomic_read(&edu->status) & EDU_STATUS_COMPUTING) {
-            break;
-        }
-        /* EDU_STATUS_COMPUTING cannot go 0->1 concurrently, because it is only
-         * set in this function and it is under the iothread mutex.
-         */
-        qemu_mutex_lock(&edu->thr_mutex);
-        edu->fact = val;
-        atomic_or(&edu->status, EDU_STATUS_COMPUTING);
-        qemu_cond_signal(&edu->thr_cond);
-        qemu_mutex_unlock(&edu->thr_mutex);
-        break;
-    case 0x20:
-        if (val & EDU_STATUS_IRQFACT) {
-            atomic_or(&edu->status, EDU_STATUS_IRQFACT);
-        } else {
-            atomic_and(&edu->status, ~EDU_STATUS_IRQFACT);
-        }
-        break;
-    case 0x60:
-        edu_raise_irq(edu, val);
-        break;
-    case 0x64:
-        edu_lower_irq(edu, val);
-        break;
-    case 0x80:
-        dma_rw(edu, true, &val, &edu->dma.src, false);
-        break;
-    case 0x88:
-        dma_rw(edu, true, &val, &edu->dma.dst, false);
-        break;
-    case 0x90:
-        dma_rw(edu, true, &val, &edu->dma.cnt, false);
-        break;
-    case 0x98:
-        if (!(val & EDU_DMA_RUN)) {
-            break;
-        }
-        dma_rw(edu, true, &val, &edu->dma.cmd, true);
-        break;
-    }
-}
-
-static const MemoryRegionOps edu_mmio_ops = {
-    .read = edu_mmio_read,
-    .write = edu_mmio_write,
-    .endianness = DEVICE_NATIVE_ENDIAN,
-    .valid = {
-        .min_access_size = 4,
-        .max_access_size = 8,
-    },
-    .impl = {
-        .min_access_size = 4,
-        .max_access_size = 8,
-    },
-
-};
-
-/*
- * We purposely use a thread, so that users are forced to wait for the status
- * register.
- */
-static void *edu_fact_thread(void *opaque)
-{
-    EduState *edu = opaque;
-
-    while (1) {
-        uint32_t val, ret = 1;
-
-        qemu_mutex_lock(&edu->thr_mutex);
-        while ((atomic_read(&edu->status) & EDU_STATUS_COMPUTING) == 0 &&
-                        !edu->stopping) {
-            qemu_cond_wait(&edu->thr_cond, &edu->thr_mutex);
-        }
-
-        if (edu->stopping) {
-            qemu_mutex_unlock(&edu->thr_mutex);
-            break;
-        }
-
-        val = edu->fact;
-        qemu_mutex_unlock(&edu->thr_mutex);
-
-        while (val > 0) {
-            ret *= val--;
-        }
-
-        /*
-         * We should sleep for a random period here, so that students are
-         * forced to check the status properly.
-         */
-
-        qemu_mutex_lock(&edu->thr_mutex);
-        edu->fact = ret;
-        qemu_mutex_unlock(&edu->thr_mutex);
-        atomic_and(&edu->status, ~EDU_STATUS_COMPUTING);
-
-        if (atomic_read(&edu->status) & EDU_STATUS_IRQFACT) {
-            qemu_mutex_lock_iothread();
-            edu_raise_irq(edu, FACT_IRQ);
-            qemu_mutex_unlock_iothread();
-        }
-    }
-
-    return NULL;
-}
-
-static void pci_edu_realize(PCIDevice *pdev, Error **errp)
-{
-    EduState *edu = EDU(pdev);
-    uint8_t *pci_conf = pdev->config;
-
-    pci_config_set_interrupt_pin(pci_conf, 1);
-
-    if (msi_init(pdev, 0, 1, true, false, errp)) {
-        return;
-    }
-
-    timer_init_ms(&edu->dma_timer, QEMU_CLOCK_VIRTUAL, edu_dma_timer, edu);
-
-    qemu_mutex_init(&edu->thr_mutex);
-    qemu_cond_init(&edu->thr_cond);
-    qemu_thread_create(&edu->thread, "edu", edu_fact_thread,
-                       edu, QEMU_THREAD_JOINABLE);
-
-    memory_region_init_io(&edu->mmio, OBJECT(edu), &edu_mmio_ops, edu,
-                    "edu-mmio", 1 * MiB);
-    pci_register_bar(pdev, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &edu->mmio);
-}
-
-static void pci_edu_uninit(PCIDevice *pdev)
-{
-    EduState *edu = EDU(pdev);
-
-    qemu_mutex_lock(&edu->thr_mutex);
-    edu->stopping = true;
-    qemu_mutex_unlock(&edu->thr_mutex);
-    qemu_cond_signal(&edu->thr_cond);
-    qemu_thread_join(&edu->thread);
-
-    qemu_cond_destroy(&edu->thr_cond);
-    qemu_mutex_destroy(&edu->thr_mutex);
-
-    timer_del(&edu->dma_timer);
-    msi_uninit(pdev);
-}
-
-static void edu_instance_init(Object *obj)
-{
-    EduState *edu = EDU(obj);
-
-    edu->dma_mask = (1UL << 28) - 1;
-    object_property_add_uint64_ptr(obj, "dma_mask",
-                                   &edu->dma_mask, OBJ_PROP_FLAG_READWRITE,
-                                   NULL);
-}
-
-static void edu_class_init(ObjectClass *class, void *data)
-{
-    DeviceClass *dc = DEVICE_CLASS(class);
-    PCIDeviceClass *k = PCI_DEVICE_CLASS(class);
-
-    k->realize = pci_edu_realize;
-    k->exit = pci_edu_uninit;
-    k->vendor_id = PCI_VENDOR_ID_QEMU;
-    k->device_id = 0x11e8;
-    k->revision = 0x10;
-    k->class_id = PCI_CLASS_OTHERS;
-    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
-}
-
-static void pci_edu_register_types(void)
-{
-    static InterfaceInfo interfaces[] = {
-        { INTERFACE_CONVENTIONAL_PCI_DEVICE },
-        { },
-    };
-    static const TypeInfo edu_info = {
-        .name          = TYPE_PCI_EDU_DEVICE,
-        .parent        = TYPE_PCI_DEVICE,
-        .instance_size = sizeof(EduState),
-        .instance_init = edu_instance_init,
-        .class_init    = edu_class_init,
-        .interfaces = interfaces,
-    };
-
-    type_register_static(&edu_info);
-}
-type_init(pci_edu_register_types)
diff --git a/hw/misc/newdev.c b/hw/misc/newdev.c
new file mode 100644
index 0000000000..fd0ae0ce98
--- /dev/null
+++ b/hw/misc/newdev.c
@@ -0,0 +1,706 @@
+/*
+ * QEMU extensible paravirtualization device
+ * 2020 Giacomo Pellicci
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include "qemu/osdep.h"
+#include "qemu/units.h"
+#include "hw/pci/pci.h"
+#include "hw/hw.h"
+#include "hw/pci/msi.h"
+#include "qemu/timer.h"
+#include "qemu/main-loop.h" /* iothread mutex */
+#include "qemu/module.h"
+#include "qapi/visitor.h"
+
+#include <sys/inotify.h>
+#include <errno.h>
+#include <poll.h>
+
+#include <sys/types.h> 
+#include <sys/socket.h> 
+
+#include "hw/misc/bpf_injection_msg.h"
+
+#include "hw/core/cpu.h"
+
+//Affinity part
+#include <sys/sysinfo.h>
+#include <sched.h>
+#define MAX_CPU 64
+#define SET_SIZE CPU_ALLOC_SIZE(64)
+#define NEWDEV_DEVICE_ID 0x11ea
+
+/* Debug information. Define it as 1 get for basic debugging,
+ * and as 2 to get additional (verbose) memory listener logs. */
+#define NEWDEV_DEBUG 1
+
+#if NEWDEV_DEBUG > 0
+#define DBG(fmt, ...) do { \
+        fprintf(stderr, "newdev-pci: " fmt "\n", ## __VA_ARGS__); \
+    } while (0)
+#else
+#define DBG(fmt, ...) do {} while (0)
+#endif
+
+#define TYPE_NEWDEV_DEVICE "newdev"
+#define NEWDEV(obj)        OBJECT_CHECK(NewdevState, obj, TYPE_NEWDEV_DEVICE)
+
+#define NEWDEV_REG_PCI_BAR      0
+#define NEWDEV_BUF_PCI_BAR      1
+#define NEWDEV_REG_END          92
+#define NEWDEV_REG_MASK         0xff
+#define NEWDEV_BUF_MASK         0xffff
+#define NEWDEV_BUF_SIZE         65536
+
+
+//not used, misleading. OLD used only in ioregs R/W
+#define NEWDEV_REG_STATUS_IRQ   0
+#define NEWDEV_REG_RAISE_IRQ    8
+#define NEWDEV_REG_LOWER_IRQ    12
+
+// DEVICE BUFMMIO STRUCTURE. OFFSET IN #bytes/sizeof(uint32_t)
+
+// +---+--------------------------------+
+// | 0 | irq_status [R] / raise_irq [W] |
+// +---+--------------------------------+
+// | 1 |          lower_irq [W]         |
+// +---+--------------------------------+
+// | 2 |      unspecified/reserved      |
+// +---+--------------------------------+
+// | 3 |      unspecified/reserved      |
+// +---+--------------------------------+
+// | 4 |                                |
+// +---+                                |
+// | 5 |            buffer              |
+// +---+                                |
+// |   |                                |
+// |   |                                |
+//                  ......
+// |   |                                |
+// |   |                                |
+// +---+--------------------------------+
+
+
+
+
+static const char *regnames[] = {
+    "STATUS",
+    "CTRL",
+    "RAISE_IRQ",
+    "LOWER_IRQ",
+};
+
+typedef struct {
+    PCIDevice pdev;
+    MemoryRegion regs;
+    MemoryRegion mmio;
+
+    /* Storage for the I/O registers. */
+    uint32_t ioregs[NEWDEV_REG_END >> 2];
+
+    /* Storage for the buffer. */
+    uint32_t *buf;
+
+    QemuThread thread;
+    QemuMutex thr_mutex;
+    QemuCond thr_cond;
+    bool stopping;
+    uint32_t irq_status;
+
+
+    bool hyperthreading_remapping; 
+    
+    int listen_fd;  //listening socket fd
+    int connect_fd; //connected socket fd (use for command exchange)
+
+} NewdevState;
+
+static void newdev_raise_irq(NewdevState *newdev, uint32_t val);
+static void connected_handle_read(void *opaque);
+int map_hyperthread(cpu_set_t* set);
+
+
+int map_hyperthread(cpu_set_t* set){
+    //Modifies cpu_set only if one cpu is set in 
+    int i=0;
+    int setCount=0;
+    int settedCpu;
+    int remappedCpu = -1;
+    for(i=0; i<MAX_CPU; i++){
+        if(CPU_ISSET_S(i, SET_SIZE, set)){
+            setCount++;
+            settedCpu = i;
+        }
+    }
+    if(setCount == 1){
+        CPU_ZERO_S(SET_SIZE, set);
+        if(settedCpu%2 == 0){
+            remappedCpu = settedCpu / 2;
+        }
+        else{
+            remappedCpu = (get_nprocs()/2) + (settedCpu / 2);
+        }
+        CPU_SET_S(remappedCpu, SET_SIZE, set);
+
+        // DBG("map_hyperthread [guest] %d -> %d [host]", settedCpu, remappedCpu);
+    }
+    return remappedCpu;
+}
+
+static void accept_handle_read(void *opaque){
+    NewdevState *newdev = opaque;
+
+    DBG("accept_handle_read\n");
+    DBG("incoming connection on socket fd:\t%d\n", newdev->listen_fd);
+    
+
+    /* CAN RAISE IRQ HERE */
+    // DBG("raising irq for fun?\n");
+    // newdev_raise_irq(newdev, 22);
+
+    //Accept connection from peer
+    newdev->connect_fd = accept(newdev->listen_fd, NULL, NULL);
+    DBG("accepted connection from peer. connect_fd:\t%d\n", newdev->connect_fd);
+
+    //Add connect_fd from list of watched fd in iothread select
+    qemu_set_fd_handler(newdev->connect_fd, connected_handle_read, NULL, newdev);
+
+
+    //Remove listen_fd from watched fd in iothread select
+    qemu_set_fd_handler(newdev->listen_fd, NULL, NULL, NULL);
+
+    //don't close listen_fd socket... useful for later reconnection ?
+    //qemu_close(newdev->listen_fd);
+    return;
+}
+
+static void connected_handle_read(void *opaque){
+    NewdevState *newdev = opaque;
+    // char buf[50];
+    int len = 0;
+    struct bpf_injection_msg_header* myheader;
+
+
+    DBG("connect_handle_read\n");
+    DBG("readable socket fd:\t%d\n", newdev->connect_fd);
+
+    // Receive message header (version|type|payload_length) [place it in newdev->buf at offset 4*sizeof(uint32_t)]
+    len = recv(newdev->connect_fd, newdev->buf + 4, sizeof(struct bpf_injection_msg_header), 0);
+    if(len <= 0){
+        DBG("len = %d [<=0] --> connection reset or error. Removing connect_fd, restoring listen_fd\n", len);
+        //connection closed[0] or error[<0]
+
+        //Remove connect_fd from watched fd in iothread select
+        qemu_set_fd_handler(newdev->connect_fd, NULL, NULL, NULL);
+        newdev->connect_fd = -1;
+
+        //Add listen_fd from list of watched fd in iothread select
+        qemu_set_fd_handler(newdev->listen_fd, accept_handle_read, NULL, newdev);  
+        return;
+    }
+    myheader = (struct bpf_injection_msg_header*) newdev->buf + 4;
+    print_bpf_injection_message(*myheader);   
+
+    // Receive message payload. Place it in newdev->buf + 4 + sizeof(struct bpf_injection_msg_header)/sizeof(uint32_t)
+    // All those manipulation is because newdev->buf is a pointer to uint32_t so you have to provide offset in bytes/4 or in uint32_t
+    len = recv(newdev->connect_fd, newdev->buf + 4 + sizeof(struct bpf_injection_msg_header)/sizeof(uint32_t), myheader->payload_len, 0);
+    // DBG("payload received of len: %d bytes", len);
+
+    //debug dump
+    // {
+    //     int payload_left = myheader->payload_len;
+    //     int offset = 0;
+    //     while(payload_left > 0){
+    //         unsigned int tmp = *(unsigned int*)(newdev->buf + 4 + sizeof(struct bpf_injection_msg_header)/sizeof(uint32_t) + offset);
+    //         DBG("value\t%x", tmp);
+    //         offset += 1;
+    //         payload_left -= 4;
+    //         if(offset > 7)
+    //             break;
+    //     }
+    // }
+
+    //big switch depending on msg.header.type
+    switch(myheader->type){
+        case PROGRAM_INJECTION:
+            // Program is stored in buf. Trigger interrupt to propagate this info
+            // to the guest side. Convention::: use interrupt number equal to case
+            DBG("PROGRAM_INJECTION-> interrupt fired");
+            newdev_raise_irq(newdev, PROGRAM_INJECTION);
+            {
+                int i=0;
+                CPUState* cpu = qemu_get_cpu(i);
+                while(cpu != NULL){
+                    DBG("cpu #%d[%d]\tthread id:%d", i, cpu->cpu_index, cpu->thread_id);
+                    i++;
+                    cpu = qemu_get_cpu(i);
+                }
+                DBG("Guest has %d vCPUS", i);
+            }
+            break;
+        case PROGRAM_INJECTION_RESULT:
+            break;
+        case PROGRAM_INJECTION_AFFINITY:
+            // Injection affinity infos are stored in buf.
+            {
+                struct cpu_affinity_infos_t* myaffinityinfo;
+                int vCPU_count=0;
+                CPUState* cpu = qemu_get_cpu(vCPU_count);
+                while(cpu != NULL){
+                    DBG("cpu #%d[%d]\tthread id:%d", vCPU_count, cpu->cpu_index, cpu->thread_id);
+                    vCPU_count++;
+                    cpu = qemu_get_cpu(vCPU_count);                
+                }
+                DBG("Guest has %d vCPUS", vCPU_count);
+                myaffinityinfo = (struct cpu_affinity_infos_t*)(newdev->buf + 4 + sizeof(struct bpf_injection_msg_header)/sizeof(uint32_t));
+                myaffinityinfo->n_vCPU = vCPU_count;
+                DBG("#pCPU: %u", myaffinityinfo->n_pCPU);
+                DBG("#vCPU: %u", myaffinityinfo->n_vCPU);
+                newdev_raise_irq(newdev, PROGRAM_INJECTION_AFFINITY);
+            }
+
+
+            break;
+        case PROGRAM_INJECTION_AFFINITY_RESULT:
+            break;
+        case SHUTDOWN_REQUEST:
+            break;
+        case ERROR:
+            return;
+        case RESET:
+            {
+                uint64_t value = 0xFFFFFFFF;                
+                cpu_set_t *set;                
+                CPUState* cpu;
+                int vCPU_count=0;
+
+                set = CPU_ALLOC(MAX_CPU);
+                memcpy(set, &value, SET_SIZE);
+
+                cpu = qemu_get_cpu(vCPU_count);
+                while(cpu != NULL){
+                    DBG("cpu #%d[%d]\tthread id:%d\t RESET affinity", vCPU_count, cpu->cpu_index, cpu->thread_id);
+                    if (sched_setaffinity(cpu->thread_id, SET_SIZE, set) == -1){
+                        DBG("error sched_setaffinity");
+                    } 
+                    vCPU_count += 1;
+                    cpu = qemu_get_cpu(vCPU_count);   
+                }  
+                CPU_FREE(set);   
+                break;
+            }
+        case PIN_ON_SAME:
+            {                            
+                cpu_set_t *set;                
+                CPUState* cpu;
+                int vCPU_count=0;
+                set = CPU_ALLOC(MAX_CPU);
+                CPU_SET_S(0, SET_SIZE, set);    //static pin on pCPU0
+
+                cpu = qemu_get_cpu(vCPU_count);
+                while(cpu != NULL){
+                    DBG("cpu #%d[%d]\tthread id:%d\t PIN_ON_SAME [pcpu#%d]", vCPU_count, cpu->cpu_index, cpu->thread_id, 0);
+                    if (sched_setaffinity(cpu->thread_id, SET_SIZE, set) == -1){
+                        DBG("error sched_setaffinity");
+                    } 
+                    vCPU_count += 1;
+                    cpu = qemu_get_cpu(vCPU_count);   
+                }  
+                CPU_FREE(set);   
+                break;
+            }
+        case HT_REMAPPING:
+            {                            
+                newdev->hyperthreading_remapping = !newdev->hyperthreading_remapping;
+                DBG("HT_REMAPPING: %d", newdev->hyperthreading_remapping);
+            }
+        default:
+            //unexpected value is threated like an error 
+            return;            
+    }
+
+    return;
+}
+
+
+static void newdev_raise_irq(NewdevState *newdev, uint32_t val){
+    newdev->irq_status |= val;
+    DBG("raise irq\tirq_status=%x", newdev->irq_status);
+    if (newdev->irq_status) {
+        DBG("raise irq\tinside if");
+        pci_set_irq(&newdev->pdev, 1);        
+    }
+}
+
+static void newdev_lower_irq(NewdevState *newdev, uint32_t val){
+    newdev->irq_status &= ~val;
+    DBG("lower irq\tirq_status=%x", newdev->irq_status);
+    if (!newdev->irq_status) {
+        DBG("lower irq\tinside if");
+        pci_set_irq(&newdev->pdev, 0);
+    }
+}
+
+static uint64_t newdev_io_read(void *opaque, hwaddr addr, unsigned size){
+    NewdevState *newdev = opaque;
+    uint64_t val;
+    unsigned int index;
+
+    addr = addr & NEWDEV_REG_MASK;
+    index = addr >> 2;
+
+    if (addr >= NEWDEV_REG_END) {
+        DBG("Unknown I/O read, addr=0x%08"PRIx64, addr);
+        return 0;
+    }
+
+    switch(addr){
+        case NEWDEV_REG_STATUS_IRQ:
+            val = newdev->irq_status;
+            break;
+        default:
+            val = newdev->ioregs[index];
+            break;            
+    }
+
+    DBG("I/O read from %s, val=0x%08" PRIx64, regnames[index], val);
+
+    return val;
+}
+
+static void newdev_io_write(void *opaque, hwaddr addr, uint64_t val, unsigned size){
+    NewdevState *newdev = opaque;
+    unsigned int index;
+
+    addr = addr & NEWDEV_REG_MASK;
+    index = addr >> 2;
+
+    if (addr >= NEWDEV_REG_END) {
+        DBG("Unknown I/O write, addr=0x%08"PRIx64", val=0x%08"PRIx64,
+            addr, val);
+        return;
+    }
+
+    assert(index < ARRAY_SIZE(regnames));
+
+    DBG("I/O write to %s, val=0x%08" PRIx64, regnames[index], val);
+
+    switch(addr){
+        case NEWDEV_REG_RAISE_IRQ:
+            newdev_raise_irq(newdev, val);
+        case NEWDEV_REG_LOWER_IRQ:
+            newdev_lower_irq(newdev, val);
+            break;
+        default:            
+            newdev->ioregs[index] = val;
+            break;
+    }
+
+}
+
+static uint64_t newdev_bufmmio_read(void *opaque, hwaddr addr, unsigned size){
+    NewdevState *newdev = opaque;
+    unsigned int index;
+
+    addr = addr & NEWDEV_BUF_MASK;
+    index = addr >> 2;
+
+    if (addr + size > NEWDEV_BUF_SIZE * sizeof(uint32_t)) {
+        DBG("Out of bounds BUF read, addr=0x%08"PRIx64, addr);
+        return 0;
+    }
+
+
+    switch(index){
+        case 0:
+            DBG("BUF read [case 0] val=0x%08" PRIx32, newdev->irq_status);
+            return newdev->irq_status;
+        default:
+            break;
+    }
+    // DBG("BUF read index=%u", index);
+    // DBG("BUF read val=0x%08" PRIx32, newdev->buf[index]);
+    return newdev->buf[index];
+}
+
+static void newdev_bufmmio_write(void *opaque, hwaddr addr, uint64_t val, unsigned size){
+    NewdevState *newdev = opaque;
+    unsigned int index;
+
+
+    addr = addr & NEWDEV_BUF_MASK;
+    index = addr >> 2;
+
+    if (addr + size > NEWDEV_BUF_SIZE * sizeof(uint32_t)) {
+        DBG("Out of bounds BUF read, addr=0x%08"PRIx64, addr);
+        return;
+    }
+
+    // DBG("BUF write val=0x%08" PRIx64, val);
+
+    switch(index){
+        case 0:
+            newdev_raise_irq(newdev, val);
+            break;
+        case 1:        
+            newdev_lower_irq(newdev, val);
+            break;
+        case 2:
+            //doorbell region for guest->hw notification
+            DBG("doorbell in device!");
+            //process this response from guest daemon...
+
+            //debug dump
+            // {
+            //     struct bpf_injection_msg_header* myheader;
+            //     myheader = (struct bpf_injection_msg_header*) newdev->buf + 4;
+            //     print_bpf_injection_message(*myheader); 
+            //     int payload_left = myheader->payload_len;
+            //     int offset = 0;
+            //     while(payload_left > 0){
+            //         unsigned int tmp = *(unsigned int*)(newdev->buf + 4 + sizeof(struct bpf_injection_msg_header)/sizeof(uint32_t) + offset);
+            //         DBG("value\t%x", tmp);
+            //         offset += 1;
+            //         payload_left -= 4;
+            //         if(offset > 7)
+            //             break;
+            //     }
+            // }
+
+            {
+                struct bpf_injection_msg_header* myheader;
+                myheader = (struct bpf_injection_msg_header*) newdev->buf + 4;
+                send(newdev->connect_fd, myheader, sizeof(struct bpf_injection_msg_header), 0);
+                send(newdev->connect_fd, newdev->buf + 4 + sizeof(struct bpf_injection_msg_header)/sizeof(uint32_t), myheader->payload_len, 0);
+            }
+
+            //reset doorbell
+            newdev->buf[index] = 0;
+            break;
+        case 3:
+            {
+                int vCPU_count=0;
+                uint64_t value = val;                
+                cpu_set_t *set;                
+                CPUState* cpu;
+
+                set = CPU_ALLOC(MAX_CPU);
+                memcpy(set, &value, SET_SIZE);                
+
+                cpu = qemu_get_cpu(vCPU_count);
+                while(cpu != NULL){
+                    DBG("cpu #%d[%d]\tthread id:%d", vCPU_count, cpu->cpu_index, cpu->thread_id);
+                    if(CPU_ISSET_S(vCPU_count, SET_SIZE, set)){
+                        int remap = vCPU_count;
+                        if(newdev->hyperthreading_remapping == true){                            
+                            remap = map_hyperthread(set);   //if 1 cpu is set then remap, otherwise do nothing
+                        }
+                        if (sched_setaffinity(cpu->thread_id, SET_SIZE, set) == -1){
+                            DBG("error sched_setaffinity");
+                        }                          
+
+                        DBG("---IOCTL_SCHED_SETAFFINITY triggered this.\nCall sched_setaffinity to bind vCPU%d(thread %d) to pCPU%d", vCPU_count, cpu->thread_id, remap);
+                    }
+                    vCPU_count++;
+                    cpu = qemu_get_cpu(vCPU_count);                
+                }                
+                DBG("#pCPU: %u", get_nprocs()); //assuming NON hotpluggable cpus
+                DBG("#vCPU: %u", vCPU_count);            
+
+                CPU_FREE(set);
+                break;
+            }
+        default:
+            newdev->buf[index] = val;
+            break;
+    }
+
+
+    return;
+}
+
+
+static const MemoryRegionOps newdev_io_ops = {
+    .read = newdev_io_read,
+    .write = newdev_io_write,
+    .endianness = DEVICE_NATIVE_ENDIAN,
+    .impl = {
+        .min_access_size = 4,
+        .max_access_size = 4,
+    },
+
+};
+
+static const MemoryRegionOps newdev_bufmmio_ops = {
+    .read = newdev_bufmmio_read,
+    .write = newdev_bufmmio_write,
+    .endianness = DEVICE_NATIVE_ENDIAN,
+    .impl = {
+        .min_access_size = 4,
+        .max_access_size = 4,
+    },
+
+};
+
+static int make_socket (uint16_t port){
+  int sock;
+  struct sockaddr_in name;
+
+  /* Create the socket. */
+  sock = socket (PF_INET, SOCK_STREAM, 0);
+  if (sock < 0)
+    {
+      perror ("socket");
+      return -1;
+    }
+
+  /* Give the socket a name. */
+  name.sin_family = AF_INET;
+  name.sin_port = htons (port);
+  name.sin_addr.s_addr = htonl (INADDR_ANY);
+  if (bind (sock, (struct sockaddr *) &name, sizeof (name)) < 0)
+    {
+      perror ("bind");
+      return -1;
+    }
+
+  return sock;
+}
+
+static void newdev_realize(PCIDevice *pdev, Error **errp)
+{
+    NewdevState *newdev = NEWDEV(pdev);
+    uint8_t *pci_conf = pdev->config;
+
+    pci_config_set_interrupt_pin(pci_conf, 1);
+
+    if (msi_init(pdev, 0, 1, true, false, errp)) {
+        return;
+    }
+
+    qemu_mutex_init(&newdev->thr_mutex);
+    qemu_cond_init(&newdev->thr_cond);
+
+    /* Init I/O mapped memory region, exposing newdev registers. */
+    memory_region_init_io(&newdev->regs, OBJECT(newdev), &newdev_io_ops, newdev,
+                    "newdev-regs", NEWDEV_REG_MASK + 1);
+    pci_register_bar(pdev, NEWDEV_REG_PCI_BAR, PCI_BASE_ADDRESS_SPACE_MEMORY, &newdev->regs);
+
+    /* Init memory mapped memory region, to expose eBPF programs. */
+    memory_region_init_io(&newdev->mmio, OBJECT(newdev), &newdev_bufmmio_ops, newdev,
+                    "newdev-buf", NEWDEV_BUF_SIZE * sizeof(uint32_t));
+    pci_register_bar(pdev, NEWDEV_BUF_PCI_BAR, PCI_BASE_ADDRESS_SPACE_MEMORY, &newdev->mmio);
+
+    newdev->buf = malloc(NEWDEV_BUF_SIZE * sizeof(uint32_t));
+    
+
+    //set_fd_handler?
+    newdev->listen_fd = -1;
+    newdev->connect_fd = -1;
+
+    //setup ht (default=disabled)
+    newdev->hyperthreading_remapping = false;
+
+    newdev->listen_fd = make_socket(9999);
+    if (newdev->listen_fd < 0){
+        return;
+    } 
+
+    DBG("socket fd:\t%d", newdev->listen_fd);
+
+    if (listen (newdev->listen_fd, 1) < 0){
+      DBG("listen error\n");
+      return;        
+    }
+    DBG("listen\n");
+
+    qemu_set_fd_handler(newdev->listen_fd, accept_handle_read, NULL, newdev);        
+    
+    DBG("qemu listen_fd added");
+
+
+    DBG("**** device realized ****");
+
+}
+
+static void newdev_uninit(PCIDevice *pdev)
+{
+    NewdevState *newdev = NEWDEV(pdev);
+
+    qemu_mutex_lock(&newdev->thr_mutex);
+    newdev->stopping = true;
+    qemu_mutex_unlock(&newdev->thr_mutex);
+    qemu_cond_signal(&newdev->thr_cond);
+    qemu_thread_join(&newdev->thread);
+
+    qemu_cond_destroy(&newdev->thr_cond);
+    qemu_mutex_destroy(&newdev->thr_mutex);
+
+    msi_uninit(pdev);
+
+
+    //unset_fd_handler
+    if (newdev->listen_fd != -1) {
+        qemu_set_fd_handler(newdev->listen_fd, NULL, NULL, NULL);
+        qemu_close(newdev->listen_fd);
+    }
+
+    DBG("**** device unrealized ****");
+}
+
+
+static void newdev_class_init(ObjectClass *class, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(class);
+    PCIDeviceClass *k = PCI_DEVICE_CLASS(class);
+
+    k->realize = newdev_realize;
+    k->exit = newdev_uninit;
+    k->vendor_id = PCI_VENDOR_ID_QEMU;
+    k->device_id = NEWDEV_DEVICE_ID;
+    
+    k->class_id = PCI_CLASS_OTHERS;
+    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
+}
+
+static void newdev_instance_init(Object *obj){    
+ 	return;
+}
+
+static void newdev_register_types(void)
+{
+    static InterfaceInfo interfaces[] = {
+        { INTERFACE_CONVENTIONAL_PCI_DEVICE },
+        { },
+    };
+    static const TypeInfo newdev_info = {
+        .name          = TYPE_NEWDEV_DEVICE,
+        .parent        = TYPE_PCI_DEVICE,
+        .instance_size = sizeof(NewdevState),
+        .instance_init = newdev_instance_init,
+        .class_init    = newdev_class_init,
+        .interfaces = interfaces,
+    };
+
+    type_register_static(&newdev_info);
+}
+type_init(newdev_register_types)
diff --git a/hw/misc/testnewdev.c b/hw/misc/testnewdev.c
new file mode 100644
index 0000000000..83afc7ce26
--- /dev/null
+++ b/hw/misc/testnewdev.c
@@ -0,0 +1,309 @@
+/*
+ * QEMU educational PCI device
+ *
+ * Copyright (c) 2012-2015 Jiri Slaby
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include "qemu/osdep.h"
+#include "qemu/units.h"
+#include "hw/pci/pci.h"
+#include "hw/hw.h"
+#include "hw/pci/msi.h"
+#include "qemu/timer.h"
+#include "qemu/main-loop.h" /* iothread mutex */
+#include "qemu/module.h"
+#include "qapi/visitor.h"
+
+/* Debug information. Define it as 1 get for basic debugging,
+ * and as 2 to get additional (verbose) memory listener logs. */
+#define NEWDEV_DEBUG 1
+
+#if NEWDEV_DEBUG > 0
+#define DBG(fmt, ...) do { \
+        fprintf(stderr, "newdev-pci: " fmt "\n", ## __VA_ARGS__); \
+    } while (0)
+#else
+#define DBG(fmt, ...) do {} while (0)
+#endif
+
+#define TYPE_NEWDEV_DEVICE "testnewdev"
+#define NEWDEV(obj)        OBJECT_CHECK(NewdevState, obj, TYPE_NEWDEV_DEVICE)
+
+#define NEWDEV_REG_PCI_BAR      0
+#define NEWDEV_REG_END          92
+#define NEWDEV_REG_MASK         0xff
+
+#define NEWDEV_REG_CTRL         4
+#define NEWDEV_REG_STATUS_IRQ   8
+#define NEWDEV_REG_RAISE_IRQ    8
+#define NEWDEV_REG_LOWER_IRQ    12
+
+
+
+#define FACT_IRQ        0x00000001
+#define DMA_IRQ         0x00000100
+
+#define DMA_START       0x40000
+#define DMA_SIZE        4096
+
+#define BUF_LEN         500
+
+static const char *regnames[] = {
+    "STATUS",
+    "CTRL",
+    "RAISE_IRQ",
+    "LOWER_IRQ",
+    "NUM_RX_QUEUES",
+    "NUM_TX_QUEUES",
+    "NUM_RX_BUFS",
+    "NUM_TX_BUFS",
+    "RX_CTX_SIZE",
+    "TX_CTX_SIZE",
+    "DOORBELL_SIZE",
+    "QUEUE_SELECT",
+    "CTX_PADDR_LO",
+    "CTX_PADDR_HI",
+    "PROG_SELECT",
+    "PROG_SIZE",
+    "DOORBELL_GVA_LO",
+    "DOORBELL_GVA_HI",
+    "VERSION",
+    "FEATURES",
+    "DUMP_LEN",
+    "DUMP_INPUT",
+    "DUMP_OFS",
+};
+
+
+typedef struct {
+    PCIDevice pdev;
+    MemoryRegion regs;
+    MemoryRegion mmio;
+
+    /* Storage for the I/O registers. */
+    uint32_t ioregs[NEWDEV_REG_END >> 2];
+
+    /* Storage for the buffer. */
+    uint32_t *buf;
+
+    QemuThread thread;
+    QemuMutex thr_mutex;
+    QemuCond thr_cond;
+    bool stopping;
+
+    uint32_t irq_status;
+
+} NewdevState;
+
+static bool newdev_msi_enabled(NewdevState *newdev)
+{
+    return msi_enabled(&newdev->pdev);
+}
+
+static void newdev_raise_irq(NewdevState *newdev, uint32_t val)
+{
+    newdev->irq_status |= val;
+    if (newdev->irq_status) {
+        if (newdev_msi_enabled(newdev)) {
+            msi_notify(&newdev->pdev, 0);
+        } else {
+            pci_set_irq(&newdev->pdev, 1);
+        }
+    }
+}
+
+static void newdev_lower_irq(NewdevState *newdev, uint32_t val)
+{
+    newdev->irq_status &= ~val;
+
+    if (!newdev->irq_status && !newdev_msi_enabled(newdev)) {
+        pci_set_irq(&newdev->pdev, 0);
+    }
+}
+
+static uint64_t newdev_io_read(void *opaque, hwaddr addr, unsigned size){
+    NewdevState *newdev = opaque;
+    uint64_t val;
+    unsigned int index;
+
+    addr = addr & NEWDEV_REG_MASK;
+    index = addr >> 2;
+
+    if (addr >= NEWDEV_REG_END) {
+        DBG("Unknown I/O read, addr=0x%08"PRIx64, addr);
+        return 0;
+    }
+
+    // assert(index < ARRAY_SIZE(regnames));
+
+    switch(addr){
+        case NEWDEV_REG_STATUS_IRQ:
+            val = newdev->irq_status;
+            break;
+        default:
+            val = newdev->ioregs[index];
+            break;            
+    }
+
+    DBG("I/O read from %s, val=0x%08" PRIx64, regnames[index], val);
+
+    return val;
+}
+
+static void newdev_io_write(void *opaque, hwaddr addr, uint64_t val, unsigned size){
+    NewdevState *newdev = opaque;
+    unsigned int index;
+
+    addr = addr & NEWDEV_REG_MASK;
+    index = addr >> 2;
+
+    if (addr >= NEWDEV_REG_END) {
+        DBG("Unknown I/O write, addr=0x%08"PRIx64", val=0x%08"PRIx64,
+            addr, val);
+        return;
+    }
+
+    assert(index < ARRAY_SIZE(regnames));
+
+    DBG("I/O write to %s, val=0x%08" PRIx64, regnames[index], val);
+
+    switch(addr){
+        case NEWDEV_REG_RAISE_IRQ:
+            newdev_raise_irq(newdev, val);
+        case NEWDEV_REG_LOWER_IRQ:
+            newdev_lower_irq(newdev, val);
+            break;
+        default:            
+            newdev->ioregs[index] = val;
+            break;
+    }
+
+}
+
+
+static const MemoryRegionOps newdev_io_ops = {
+    .read = newdev_io_read,
+    .write = newdev_io_write,
+    .endianness = DEVICE_NATIVE_ENDIAN,
+    .impl = {
+        .min_access_size = 4,
+        .max_access_size = 4,
+    },
+
+};
+
+
+static void newdev_realize(PCIDevice *pdev, Error **errp)
+{
+    NewdevState *newdev = NEWDEV(pdev);
+    uint8_t *pci_conf = pdev->config;
+
+    DBG("**** starting realize... ****");
+    pci_config_set_interrupt_pin(pci_conf, 1);
+
+    if (msi_init(pdev, 0, 1, true, false, errp)) {
+        return;
+    }
+
+    //timer_init_ms(&newdev->dma_timer, QEMU_CLOCK_VIRTUAL, newdev_dma_timer, newdev);
+
+    qemu_mutex_init(&newdev->thr_mutex);
+    qemu_cond_init(&newdev->thr_cond);
+
+    /* Init I/O mapped memory region, exposing newdev registers. */
+    memory_region_init_io(&newdev->regs, OBJECT(newdev), &newdev_io_ops, newdev,
+                    "newdev-regs", NEWDEV_REG_MASK + 1);
+    pci_register_bar(pdev, NEWDEV_REG_PCI_BAR, PCI_BASE_ADDRESS_SPACE_MEMORY, &newdev->regs);
+
+
+    // newdev->buf = malloc(NEWDEV_BUF_SIZE * sizeof(uint32_t));
+
+    /* Initialize device buffer */
+    // s->buf = g_malloc0(BUF_LEN);
+
+    DBG("**** device realized ****");
+}
+
+static void newdev_uninit(PCIDevice *pdev)
+{
+    NewdevState *newdev = NEWDEV(pdev);
+
+    qemu_mutex_lock(&newdev->thr_mutex);
+    newdev->stopping = true;
+    qemu_mutex_unlock(&newdev->thr_mutex);
+    qemu_cond_signal(&newdev->thr_cond);
+    qemu_thread_join(&newdev->thread);
+
+    qemu_cond_destroy(&newdev->thr_cond);
+    qemu_mutex_destroy(&newdev->thr_mutex);
+
+    // timer_del(&newdev->dma_timer);
+    msi_uninit(pdev);
+
+    DBG("**** device unrealized ****");
+}
+
+
+static void newdev_class_init(ObjectClass *class, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(class);
+    PCIDeviceClass *k = PCI_DEVICE_CLASS(class);
+
+    k->realize = newdev_realize;
+    k->exit = newdev_uninit;
+    k->vendor_id = PCI_VENDOR_ID_QEMU;
+    k->device_id = 0x11ea;
+    // k->revision = 0x10;
+    k->class_id = PCI_CLASS_OTHERS;
+    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
+    // k->vmsd = &vmstate_newdev;
+    // k->props = newdev_properties;
+}
+
+static void newdev_instance_init(Object *obj)
+{
+    
+    //NewdevState *edu = NEWDEV(obj);
+
+    // edu->dma_mask = (1UL << 28) - 1;
+    // object_property_add_uint64_ptr(obj, "dma_mask",
+    //                                &edu->dma_mask, OBJ_PROP_FLAG_READWRITE,
+    //                                NULL);
+}
+
+static void newdev_register_types(void)
+{
+    static InterfaceInfo interfaces[] = {
+        { INTERFACE_CONVENTIONAL_PCI_DEVICE },
+        { },
+    };
+    static const TypeInfo newdev_info = {
+        .name          = TYPE_NEWDEV_DEVICE,
+        .parent        = TYPE_PCI_DEVICE,
+        .instance_size = sizeof(NewdevState),
+        .instance_init = newdev_instance_init,
+        .class_init    = newdev_class_init,
+        .interfaces = interfaces,
+    };
+
+    type_register_static(&newdev_info);
+}
+type_init(newdev_register_types)
diff --git a/make-deb.sh b/make-deb.sh
new file mode 100755
index 0000000000..00d8888413
--- /dev/null
+++ b/make-deb.sh
@@ -0,0 +1,21 @@
+#!/usr/bin/env bash
+
+mkdir -p rootfs build
+cd build && \
+../configure \
+	--target-list="x86_64-softmmu" \
+	--enable-debug \
+	--disable-docs \
+	--disable-capstone \
+	--disable-nettle \
+	--enable-virtfs \
+	--disable-gnutls \
+	--disable-gcrypt \
+	--extra-cflags="-O0" \
+	--enable-trace-backends=ftrace
+
+make all -j$(nproc) CONFIG_NEWDEV=y CONFIG_VIRTFS=y CONFIG_VIRTIO_9P=y
+
+make DESTDIR=/code/rootfs sharedir="/usr/share/qemu" datadir="/usr/share/qemu" install
+cp -rf /code/rootfs/* /code/debbuild/
+dpkg-deb -v --build /code/debbuild /code/newdev-qemu.deb
-- 
2.35.1

